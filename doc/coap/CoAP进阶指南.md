
##7, 发现
###7.1, 服务发现

作为CoAP服务端提供的发现服务的一部分，客户端需要对服务端有所了解。

客户端发现服务端，是客户端通过从URI中获取或学习服务端命名空间中的资源来做到的。另外，客户端能够使用多播CoAP（第8章）和“All CoAP Nodes”多播地址来查找CoAP服务端。

除非“coap”或者“coaps”URI中指定了服务端的UDP 端口，否则服务端默认是能够通过默认端口连接的。

提供资源发现（见7.2节）的服务端必须支持，提供其他资源的服务端应该支持CoAP默认端口号5683。对于DTLS加密类型的CoAP，提供资源发现和提供其他资源的服务端可能支持默认5684端口。此外，其他端可能采用另外的端口，例如，端口动态分配情况下。

实现注意：当一个CoAP服务端是由6LowPAN节点提供，当端口使用[[RFC4944]](http://tools.ietf.org/pdf/rfc4944)和[[RFC6282]](http://tools.ietf.org/pdf/rfc6282)定义的UDP端口压缩方式，采用61616-61632之间的端口号时，头部的压缩会更好。注意，如果某个服务端的UDP端口和默认端口不同，可以将它们（采用非默认端口的和采用默认端口的）视为两个不同的端。

###7.2, 资源发现

CoAP端提供的资源发现在M2M（machine-to-machine）应用中相当有用，因为在其中没有人的干预，而固定的接口又会导致连接的难复用性和较差的鲁棒性。为了最大化CoRE环境的互用性，一个CoAP端应该支持[[RFC6690]](http://tools.ietf.org/pdf/rfc6690)描述的可发现资源的CoRE连接格式，除非要求完全手动配置。由服务端来决定哪些资源能够被发现（如果有的话）。

####7.2.1, ‘ct’ 特性
这节定义了一种采用[[RFC6690]](http://tools.ietf.org/pdf/rfc6690)的新的web连接（Web Linking [[RFC5988]](http://tools.ietf.org/pdf/rfc5988)）特性。Content-Format码“ct”特性提供了该资源会返回哪种Content-Format的提示。注意，由于这仅仅是一个暗示，并不会取代针对某个资源表现的请求的回复中的Content-Format选项。“ct”特性的值是采用CoAP编码格式的十进制整型ASCII码，而且必须在0-65535范围内。举个例子，“application/xml”被定义成“ct=41”。如果Content-Format特性不存在，那么该类型无意义。Content-Format码特性可能包含一个用空格分隔开的Content-Format码序列，表明多个content-format可用。这个特性的值的语法在下面被总结，其中“cardinal”、“SP”、“DQUOTE”在[[RFC6690]](http://tools.ietf.org/pdf/rfc6690)中定义。

		ct-value = cardinal
		/ DQUOTE cardinal *( 1*SP cardinal ) DQUOTE
 

##8, 多播CoAP

CoAP支持在IP多播组中发送请求，这相当于连续的单播CoAP。更多关于多播组内CoAP的交互讨论在[GROUPCOMM]。

那些希望其他端能够发现的CoAP端，采用多播服务发现，加入一个或多个适当的all-CoAP-node的多播地址（12.8节）并且监听默认CoAP端口（注意，这些端可能会收到其他多播地址的多播请求，包含all-nodes的IPV6地址或者IPV4广播）。因此一个端必须做好接收这些消息的准备，但如果没有提供多播发现服务的话，可以忽略它们。

###8.1, 消息层
多播请求的特点是目的地址由具体的CoAP端地址变成了IP多播地址，多播请求必须是不需应答消息。

服务端**应该**能够识别出这些通过多播发来的请求，例如，尽量使用现有的API，如IPV6_RECVPKTINFO [[RFC3542]](http://tools.ietf.org/pdf/rfc3542).

为了避免错误的响应，当服务端发现该请求是通过多播接收的，必须不能返回RST消息给NON。如果没有发现（为多播请求），服务端可能会返回一个RST消息给NON。由于这种RST消息看起来和发送者发送的单播消息相同，发送者必须避免使用一个可能依然在其他接收到多播消息的端中依旧使用的Message ID。在撰写本文档的时侯，多播消息只能用于不含DTLS的CoAP。因此意味着在本文档中为CoAP定义的安全模式并不适用于多播。

###8.2, 请求/响应层
当服务端发现某个多播请求，它可能会一直忽略这个请求，特别是当它没有任何有用的回复（比如说，它只有一个空的payload或者一个错误响应）。这个判断是由应用决定的（例如，在请求过滤 [[RFC6690]](http://tools.ietf.org/pdf/rfc6690)中，当过滤条件不满足时，服务端不会响应多播请求。更多例子见 [GROUPCOMM]）。

如果服务端决定响应一个多播请求，它不**应该**立即响应。相反它**应该**会等待一段时间才进行**响应**。我们把这段时间称为空闲（Leisure）时间。空闲时间的值可能由应用决定，也可能由下面的描述中得到。服务端应该在选取的空闲时间中的某个随机时间发送一个单播响应给该多播请求。如果再次收到同一个多播组的请求，一个新的空闲时间最早需在上一个空闲时间结束后才能开始。

为了计算出一个空闲时间，服务端必须有一个组大小估计G，一个目标数据传输率R（二者都必须谨慎的选择），一个估计的回复大小S，一个大致的空闲时间计算公式如下：

	lb_Leisure = S * G / R

举个例子，一个在2.4G频段，采用IEEE 802.15.4（6LoWPAN）的本地网络中，G可能被设置成100，S为100字节，目标速率R为8kbits/s = 1kB/s。那么空闲时间为100 * 100 / 1000 = 10秒。

如果一个CoAP端不能获得足够的数据来计算空闲时间，它可能采用DEFAULT_LEISURE。

当匹配一个多播请求的回复时，仅仅token必须要匹配。回复的源端不需要（可能也不会）和原始请求的目的端匹配。

为了解释表现中的Location-*选项和任何嵌入的链接，请求URI（例如，响应对应的基本URI）通过将原始请求URI的host组件中的多播地址替换成实际响应的端的ip地址。

####8.2.1, Caching

当客户端发出多播请求，它经常生成一个新的请求给多播组（因为组中可能有新成员，或者没有收到之前的请求）。它可能将接收到的回复的缓存更新。然后，它同时采用cached-still-fresh和新的响应作为请求的响应。

向一个多播组发送的GET请求的响应，可能被用于满足相关的单播请求URI的后续请求。单播请求URI中的authority部分即回复包中的传输层源地址。

通过发送一个get请求给涉及到的单播请求URI，一个响应回复可能重新生效。

向多播组发送的get请求必须不能包含ETag选项。抑制客户端已有的响应包的机制仍有待进一步研究。

####8.2.2, 代理
当一个正向代理收到一个带有Proxy-Uri或从Proxy-Scheme中构建的URI，且其为多播地址，代理如上所述，会获得一个响应集合，并且会发送所有的所有的响应包（包括cached-still-fresh的和新的）给原始客户端。

协议并没有提供对被修改的单播请求URI（基本URI）的返回方式，因此转发。转发多播请求在[GROUPCOMM]中有更仔细的讨论，一种定位基本URI的方案可在[COAP-MISC]第3章中找到。



##9, 安全CoAP
本章节定义CoAP中的DTLS绑定。
在配置阶段，要为CoAP设备提供它需要的安全信息，包括密钥卡片和访问控制表。本规范在9.1.3.2.1中定义了RawPublicKey模式下的配置。在配置的最后阶段，设备会处于下面四种安全模式下的一种，并带有模式的附属信息。本规范中NoSec和RawPublicKey模式都是强制执行的。

*	NoSec：没有协议层的安全(禁用DTLS)。合适的情况下，应当使用其他技术来提供底层的安全机制。在[IPsec-CoAP]中讨论IPsec的使用。某些使用受限节点的链路层也提供链路层安全机制，它可能适用于合适的密钥管理。

*	PreSharedKey：DTLS被启用，有一个预先共享的密钥列表[[RFC4279]](http://tools.ietf.org/pdf/rfc4279)，而且每个密钥都包括节点列表(参见9.1.3.1节)。极端情况下，一个密钥对应一个节点(1:1 node/key比例)。如果两个以上的实体共享一个特定的预先共享密钥，那么该密钥只把实体认证为那个组的成员，而不是单独的一个对象。

*	RawPublicKey：DTLS被启用，设备有一个非对称密匙对，但是没有证书（一个原始公钥），它是使用out-of-band机制[[RFC7250]](http://tools.ietf.org/pdf/rfc7250)来验证的，如9.1.3.2节中所述。该设备也有一个从公钥计算来的身份和一个可以沟通的节点的身份列表。

*	Certificate:DTLS被启用，设备有一个带有X.509证书[[RFC5280]](http://tools.ietf.org/pdf/rfc5280)的非对称密钥对，与它的目录绑定，并由一些常见的受信任的根证书颁发机构颁发，如9.1.3.3节所述。设备也有根信任锚的列表，可用于验证证书。

在“NoSec”模式下，系统只需向某个IP和端口发送带"coap" scheme头的UDP数据包即可。但只有当攻击者不能利用CoAP节点收发包时才是安全的；在11.5节中有关于这个问题的附加描述。

另外3种安全模式都利用DTLS实现，并且由“coaps” scheme和DTLS下的CoAP默认端口标识。这是是一个能用于认证(带有安全模型的限制)的安全关联，基于这个认证，可以授权其他的通信端。CoAP本身不提供用于认证或者授权的协议原语；当需要的时候，由通信安全(比如IPSec或DTLS)或者对象安全(带有负载)提供。在特定操作需要认证的设备通常使用这两种安全方式。在涉及中间人的地方，只有当中间人是信任体系中的一部分时才能保证通信安全。CoAP并没有提供一种方法来转发不同级别的授权，客户端可能与其他中间人或原始服务器有这些授权，因此可能需要在第一个中间人的时候就要执行所有授权。
###9.1, DTLS-Secured CoAP
如同HTTP在TCP中使用TLS来保证安全一样，CoAP在UDP之上使用DTLS[[RFC6347]](http://tools.ietf.org/pdf/rfc6347)来保证安全(图13)。本节定义了CoAP绑定到DTLS和适合受限环境的必须强制执行最低的配置。绑定是通过一系列的单播CoAP增量来定义的。实际上，DTLS就是TLS和附加功能来处理UDP传输的不可靠特性。
			
			+----------------------+
			|      Application     |
			+----------------------+
			+----------------------+
			|  Requests/Responses  |
			|----------------------|  CoAP
			|       Messages       |
			+----------------------+
			+----------------------+
			|         DTLS         |
			+----------------------+
			+----------------------+
			|          UDP         |
			+----------------------+
      		图 13: DTLS-Secured CoAP的抽象分层

在一些受限节点(有限的flash和RAM)和网络(受限带宽或者高可扩展性要求)中，依赖于正在使用的特定密码组合，DTLS的所有模式可能是不可用的。一些DTLS密码组合在设置安全关联时，可能增加一些复杂的重要实现以及一些所需的初始信号交换开销。一旦完成最初的握手，DTLS添加一个大约13字节的有限的per-datafgram开销，不包括任何的初始化向量/随机数(例如8个字节的TLS\_PSK\_WITH\_AES\_128\_CCM\_8[[RFC6655]](http://tools.ietf.org/pdf/rfc6655)),完整性检查值(例如8个字节的TLS\_PSK\_WITH\_AES\_128\_CCM\_8[RFC6655]),和一些密码组合要求的填充值。考虑到可能适用的特定密码组，应该仔细权衡DTLS的给定模式是否适用于以CoAP为基础的应用程序，会话维护是否与应用流程兼容，用于约束节点和额外的网络开销的资源是否足够。(对于一些使用DTLS的模式，本规范确定了一个强制执行的密钥组。当这些密钥组的确合适时，能实现最大化的互通性。应用的特定安全策略可以决定使用的实际密钥组的实际设置)。DTLS不适用于组密钥(多播通信)；然而，它可能是未来组密钥管理协议中的一部分。

####9.1.1, 消息层
一个端能够作为CoAP客户端也应该能够作为DTLS客户端。它应该在合适的端口向服务端发起会话。当DTLS的握手结束时，客户端可能发起第一个CoAP请求。所有的CoAP消息必须当做DTLS"应用数据"发送。

为了将ACK消息或RST消息匹配到CON消息，或者RST消息匹配到NCON消息，附加上下面的规则：DTLS会话必须一致，时间段必须一致。

当消息在发送时有一致的DTLS会话、一致的时间段和相同的消息ID，那么消息就是一致的。

注意：当重传一个CON消息，尽管CoAP的消息ID一致，但每次尝试都会使用一个新的DTLS序列号。因此接收者必须按照4.5节中描述的去执行重复数据删除。重传不能跨时间段执行。

在RawPublicKey和认证模式中的DTLS连接被设置为使用相互验证，因此它们能在两个方向上维持连接并重用于未来的消息交换。当设备需要恢复资源时，设备可以关闭一个DTLS连接，但是通常它们必须尽可能保持长连接。在每次CoAP消息交换后关闭DTLS连接是很低效的。

####9.1.2, 请求/响应层

为了将响应匹配到请求上，加上下面的规则：DTLS会话必须一致，时间段必须一致。

这意味着对于一个DTLS安全请求的响应必须一直使用相同的安全会话和时间段。任何想提供一个DTLS请求的NoSec响应的尝试并不匹配这个请求，因此必须被拒绝（除非它匹配一个无关的NoSec请求）。

####9.1.3， 端点身份
按照[[RFC6066]](http://tools.ietf.org/pdf/rfc6066)的第3节的定义，设备应当支持服务器名称指示(SNI)来指示在SNI主机名称域中的授权。有了这个特性，当一个作为多个权威的虚拟服务器的主机接收到新的DTLS连接时，它知道这个DTLS会话要使用哪个密钥。
#####9.1.3.1，Pre-Shared Keys
当形成一个新节点的连接时，系统根据它试图到达哪些节点来选择一个适当的密钥，然后使用DTLS PSK（预共享密钥）形成一个DTLS会话。在这些模式中的执行必须支持强制执行密码组TLS\_PSK\_WITH\_AES\_128\_CCM\_8，如[[RFC6655]](http://tools.ietf.org/pdf/rfc6655)中所规定的。

根据调试模型，应用可能需要为身份提示定义应用规范(参见[[RFC4279]的5.2节](http://tools.ietf.org/pdf/rfc4279#section-5.2))，以支持PSK身份提示的使用。

应用了[[RFC4279]中第7节](http://tools.ietf.org/pdf/rfc4279#section-7)的安全性考虑。应用应当仔细权衡它是否需要完全正向保密(PFS)，并且选择一个合适的密钥组([[FRC4279]的7.1节](http://tools.ietf.org/pdf/rfc4279#section-7.1)).PSK的信息熵必须足够应付强力攻击(PSK不是随机选择的而是人为选择的)和字典式攻击([[RFC4279]的7.2节](http://tools.ietf.org/pdf/rfc4279#section-7.2))。客户端身份的明文通信可能会泄露数据或者隐私([[RFC4279]的7.3节](http://tools.ietf.org/pdf/rfc4279#section-7.3))。
#####9.1.3.2， 原始公钥证书
在这种模式下，设备有个非对称密钥对但是没有X.509证书(原始公钥)；例如，非对称秘钥对是由厂商生成并安装在设备上(参见11.6节)。一个设备可能配置了多个原始公钥。原始公钥的类型和长度取决于所使用的密钥组。在RawPublicKey模式中执行必须支持强制执行的密码组TLS\_ECDHE\_ECDSA\_WITH\_AES\_128\_CCM\_8，如[[RFC7251]](http://tools.ietf.org/pdf/rfc7251)，[[RFC5246]](http://tools.ietf.org/pdf/rfc5246)和[[RFC4492]](http://tools.ietf.org/pdf/rfc4492)中所规定的。使用的秘钥必须带有ECDSA。curve secp256r1必须支持[[RFC4492]](http://tools.ietf.org/pdf/rfc4492)；这和NIST P-256 curve相等。这个哈希算法是SHA-256。实现必须使用Supported Elliptic Curves和被支持的点格式扩展[[RFC4492]](http://tools.ietf.org/pdf/rfc4492)；必须支持未压缩的点格式；[[RFC6090]](http://tools.ietf.org/pdf/rfc4492)可以作为一个实现方法。一些有关实现这个密钥组的指导可以在[W3CXMLSEC]中找到。使用原始公钥与TLS的机制在[[RFC7250]](http://tools.ietf.org/pdf/rfc7250)中有规定。

实现注意：这意味着在图14中列出的带有至少一个值的扩展将出现在DTLS握手中。

    Extension: elliptic_curves
    Type: elliptic_curves (0x000a)
    Length: 4
    Elliptic Curves Length: 2
    Elliptic curves (1 curve)
    Elliptic curve: secp256r1 (0x0017)

    Extension: ec_point_formats
    Type: ec_point_formats (0x000b)
    Length: 2
    EC point formats Length: 1
    Elliptic curves point formats (1)
    EC point format: uncompressed (0)

    Extension: signature_algorithms
    Type: signature_algorithms (0x000d)
    Length: 4
    Data (4 bytes): 00 02 04 03
    HashAlgorithm: sha256 (4)
    SignatureAlgorithm: ecdsa (3)

    图14: TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 的DTLS扩展表示

######9.1.3.2.1, 配置
RawPublicKey模式被设计成可轻易配置在M2M部署里。假定每个设备有一个已经安装好的非对称公钥对。在[[RFC6920]](http://tools.ietf.org/pdf/rfc6920)的第2节中描述了端点从公钥中计算出标识符。所有支持检查RawPublicKey标识符的执行必须至少支持sha-256-120模式(SHA-256截断为120位).实现也应当支持更长的长度标识符和可以支持更短的长度。请注意更短的长度在面对攻击时提供更少的安全保护，因此不推荐使用。
通过URI、二进制、与/或人可识别的格式，标识符被给到验证它们的系统。
[[RFC6920]](http://tools.ietf.org/pdf/rfc6920)。所有的实现应当支持二进制模式，并且包含用户接口的实现也要支持人可识别的格式。

在配置期间，收集每个节点的标识符，例如通过读取设备外部的条形码或者获取标识符的预编译列表。这些标识符安装在相关的节点中，例如一个M2M的数据收集服务端。标识符用于两个目的，与端点连接更多的设备信息和执行访问控制。在（最初的和进行的）配置期间，标识符的访问控制列表也应该安装和维护，用这些标识符，设备可以开始DTLS会话。

#####9.1.3.3， X.509证书
在证书模式下实现必须支持强制实施的密码组TLS\_ECDHE\_ECDSA\_WITH\_AES\_128\_CCM\_8如[[RFC7251]](http://tools.ietf.org/pdf/rfc7251)，[[RFC5246]](http://tools.ietf.org/pdf/rfc5246)和[[RFC4492]](http://tools.ietf.org/pdf/rfc4492)中所规定。即证书包括SubjectPublicKeyInfo，它会显示带有danamedCurves secp256r1的id-ecPublicKey的算法 [[RFC5480]](http://tools.ietf.org/pdf/rfc5480)；公钥格式是未压缩的[[RFC5480]](http://tools.ietf.org/pdf/rfc5480)；哈希算法是SHA-256；如果包括的话，密匙使用扩展显示数字签名。证书必须使用secp256r1签署ECDSA，而且签名必须使用SHA-256。使用的密匙必须是ECDSA capable。必须支持curve secp256r1[[RFC4492]](http://tools.ietf.org/pdf/rfc4492)；这个曲线和NIST P-256曲线是等效的。哈希算法是SHA-256。实现必须使用Supported Elliptic Curves和Supported Point Formats Extensions[[RFC4492]](http://tools.ietf.org/pdf/rfc4492);必须支持未压缩的点格式；[[RFC6090]](http://tools.ietf.org/pdf/rfc6090)可以作为一个实现方法。

证书的主语会从该设备长期的惟一标识符中建立，例如 EUI-64 [EUI64]。这个主语也可以基于完全限定域名(FQDN)，它是被用作CoAP URI的主机部分。然而，设备的IP地址一般不能当做主语，因为它是可变的。系统中的发现过程会建立给定设备的IP地址和每个设备主语之间的映射。一些含有多于一个主语的设备也必须包含多个证书。

当生成一个新的连接，远程设备的证书就需要验证。如果CoAP节点有一个绝对时间的来源，那么节点应当检查证书的有效时间在范围之内。为了达到安全要求，证书必须被验证为适合于安全需求，使用的功能相当于[[RFC5280]第6节](http://tools.ietf.org/pdf/rfc5280.pdf#section-6)中指定的算法。如果认证包含一个SubjectAltName，那么请求URI的授权必须匹配至少一个在SubjectAltName族中URI类型域中的任何CoAP URI的授权。如果在证书中没有SubjectAltName，那么除了有通配符的证书不被允许以外，请求URI的授权必须匹配证书中的通用名(CN)，使用[http://tools.ietf.org/pdf/rfc3280](http://tools.ietf.org/pdf/rfc3280)中定义的匹配规则。

证书状态检查的核心支持需要进一步研究。由于在线证书状态协议(OCSP)[[RFC6960]](http://tools.ietf.org/pdf/rfc6960)到CoAP的映射当前没有被定义，而且OCSP也可能不是很容易适用于所有环境，所以另一种方法可能是使用TLS证书状态请求扩展（[[RFC6066]第8节](http://tools.ietf.org/pdf/rfc6066#section-8)；也被称为“OCSP装订”）或最好是多个证书状态扩展（[[RFC6961]](http://tools.ietf.org/pdf/rfc6961)），如果可用的话。

如果系统除了证书外还有一个共享密钥，那么应该使用一个包括共享密钥（如TLS\_ECDHE\_PSK\_WITH\_AES\_128\_CBC\_SHA[[RFC5489]](http://tools.ietf.org/pdf/rfc5489)）的密码组。

##10, CoAP和HTTP的跨协议代理
CoAP支持HTTP功能的有限子集，因此从CoAP代理到HTTP是很简单的。在CoAP和HTTP之间采用代理可能有几个原因，例如，在设计一个这两种协议都可以使用的网站界面，或在实现CoAP-HTTP代理时。同样地，CoAP也可以代理到诸如XMPP[[RFC6120]](http://tools.ietf.org/pdf/rfc6120)或者SIP[[RFC3264]](http://tools.ietf.org/pdf/rfc3264)等协议；这些代理机制的定义超出本规范的范围。

通过一个正向代理来访问资源有两个可能的方向：

CoAP-HTTP代理：通过一个中间人使得CoAP客户端访问HTTP服务端的资源。这是通过在CoAP-HTTP代理的CoAP请求里包含带有“http”或“https”URI的Proxy-Uri或Proxy-Scheme选项发起的。

HTTP-CoAP代理：通过一个中间人使得HTTP客户端访问CoAP服务端的资源。这是通过在HTTP-CoAP代理的HTTP请求的Request-Line 中指定“coap”或“coaps”URI发起的。

无论哪种方式，只有CoAP的请求/响应模型被映射到HTTP。CON或者NON消息等模型应该是透明的，对代理功能没有影响。下面的章节描述对正向代理的请求的处理。没有提及反向代理，因为代理功能对客户端是透明的，就相当于原始服务器一样。然而，对反向代理的考虑和对正向代理的考虑应该是一样的，而且通常会期望反向代理以与正向代理类似的方式运行。实现中需注意，HTTP客户端函数库没有提供一种方法将CoAP URI放在HTTP的 request-Line中，使得操作HTTP-CoAP正向代理变得困难；反向代理可能因此有更好的适用性。另外一份规范会定义例如HTTP-CoAP反向代理的的URIs操作的规定[MAPPING]。

###10.1	CoAP-HTTP代理
如果‘http’或‘https’URI中的请求包含Proxy-Uri或者Proxy-Scheme选项[[RFC2616]](http://tools.ietf.org/pdf/rfc2616)，那么接收的CoAP端点(今后称为“代理”)要求对指明的HTTP资源执行请求方法中指定的操作，并向客户端返回结果。(可参考5.7节，如何生成包含安全要求的代理请求)

这一节为所有CoAP 请求指定了代理应该返回到客户端的CoAP响应。代理实际如何响应请求是一个实现细节，期望的典型情况是代理转发请求到HTTP源服务端。

由于HTTP和CoAP共享基本的请求方法集，因此在HTTP资源上执行CoAP请求与在CoAP资源上执行它并没有什么不同。本节的下面的小节中将解释在HTTP资源上执行的每个CoAP方法的含义。

如果代理不能或者不愿服务带有HTTP URI的请求，那么向客户端返回5.05(Proxying Not Supported)响应。如果代理通过与第三方交互(例如HTTP原始服务端)来服务请求，并且无法再合理的时间内获得结果，返回一个5.04(GateWay Timeout)的响应；如果可以获取结果但是不能解释该结果，返回5.02(Bad Gateway)的响应。

####10.1.1,	GET
GET方法请求代理返回一个由请求URI定位的HTTP资源表现。

一旦成功了，必须返回2.05(Content)响应码。响应的payload必须是目标HTTP资源的表现，而且必须设定相应的Content-Format选项。响应必须携带Max-Age值，这个值不大于该资源的刷新剩余时间。如果HTTP实体有一个实体标记，代理必须在响应中包含ETag选项，并且按照下面的描述处理请求中的ETag选项。

客户端可以通过包含下面的选项来影响GET请求的流程：

*	Accept：请求可以包含一个Accept选项，标识优先的响应内容格式。

*	ETag：请求可以包含一个或多个ETag选项，标识客户端存储的响应。这就要求当代理需要发送2.03(Valid)响应时，转而发送带有请求的实体标记的2.05(Content)响应。请注意CoAP ETags是HTTP看来的强ETags；CoAP没有HTTP的弱ETags，并且在跨协议代理中没有好的方式来使用它们。
####10.1.2,	PUT
PUT方法要求代理按照请求URI定位的路径来更新或者创建HTTP资源。

如果按照请求URI创建了一个新的资源，那么必须向客户端发送2.01(Created)的响应。如果修改了一个已经存在的资源，那么必须返回一个2.04(Changed)响应来标示请求的成功完成。
####10.1.3, DELETE
DELETE方法请求代理在HTTP源服务端按照请求的URI删除HTTP资源。

如果成功了或者在请求时不存在该资源，那么向客户端发送一个2.02(Deleted)响应。
####10.1.4, POST
POST方法要求代理将包含在请求中的表现更新到HTTP原始服务端。POST方法的实际执行结果由原始服务端决定，并且依赖于请求URI定位的资源。

如果通过POST方法执行的动作不会产生一个可以由URI来标识的资源，那么必须向客户端回复2.04(Changed)的响应。如果资源在源服务端被创建，那么必须返回2.01(Created)的响应。
###10.2, HTTP-CoAP代理
如果一个HTTP请求包含带有“coap”或者“coaps”URI的Request-URI，那么接收的HTTP端(今后称为“代理”)要求对指明的CoAP资源执行请求方法中指定的操作，并向客户端返回结果。本小节定义了针对任何HTTP请求，代理应该向客户端返回的响应。除非另有说明，所有的申明都是**推荐**的行为，在一些特别受限的实现需要使用简化方式。代理如何响应请求是一个执行细节，然而期望的典型情况是代理转发请求到CoAP原始服务端。在下面的小节中将解释在CoAP资源上执行的每个HTTP方法的含义。

如果代理不能或者不想服务带有CoAP URI的请求，将会向客户端返回501(Not Implemented)响应。如果代理通过与第三方交互(比如CoAP原始服务端)来服务请求，并且无法再合理的时间内获得结果，返回一个5.04(GateWay Timeout)的响应；如果可以获取结果但是不能解释该结果，返回5.02(Bad Gateway)的响应。
####10.2.1	OPTIONS and TRACE
由于CoAP不支持OPTIONS和TRACE方法，必须向客户端返回501(Not Implemented)错误。
####10.2.2， GET
GET方法要求代理返回由Request-URI定位的CoAP资源的表现。

一旦成功，返回200(OK)响应码。响应的payload必须是目标CoAP资源的表现，而且必须设定相应的Content-Type和Content-Encoding域。响应必须携带Max-Age值，这个值不大于该资源的刷新剩余时间。如果CoAP响应有一个ETag选项，代理必须在响应中包括一个ETag头。

客户端可以通过包含下面的选项来影响GET请求的流程：

*	Accept：在请求中的HTTP Accept头的优先采用的媒体类型被映射到一个CoAP Accept选项。HTTP Accept 媒体类型的范围，参数和扩展都不被CoAP的Accept选项支持。如果代理不能找到双方（服务端和客户端）同时可以接受的的Accept域，那么代理将发送406响应。代理可能使用从HTTP Accept头的其他媒体类型来重新发起请求。

*	Conditional GETS：有条件的HTTP GET要求能够被映射到对应CoAP请求的的“If-Match”或“If-None-Match”请求头域。“If-Modified-Since”和“If-Unmodified-Since”请求头域不能直接被CoAP支持，但是能够被缓存代理在本地执行。

####10.2.3， HEAD
除了服务端**必须不**能在响应中返回一个消息体，HEAD方法与GET是一样的。

尽管在CoAP中没有与HTTP的HEAD方法直接等效的方法，HTTP-CoAP代理能够对CoAP资源的HEAD请求作出响应，并且返回不带消息体的HTTP头。

实现注意：HTTP-CoAP代理可能试着使用块传输选项来减小每次传输的数据量，但是需要注意原始服务端是否支持块传输。

####10.2.4, POST
POST方法要求代理将包含在请求中的表现更新到CoAP原始服务端。POST方法实际执行的功能由原始服务端决定，并且依赖于请求URI指定的资源。

如果通过POST方法执行的动作不会产生一个可以由URI来标识的资源，那么必须向客户端返回一个200(OK)或者204(No Content)的响应。如果在源服务端已经创建了资源，那么必须返回201(Created)响应码。

如果在CoAP响应中有任何的Location-\*选项，将返回由这些选项的值构造的Location header域。
####10.2.5, PUT
PUT方法要求代理更新或者创建由请求URI定位的CoAP资源。

如果根据请求URI创建了一个新的资源，那么向客户端返回201(Created)响应码。如果修改了存在的资源，发送200(OK)响应码或者204(No Content)响应码来标示请求的成功完成。
####10.2.6, DELETE
DELETE方法要求代理在CoAP原始服务端删除由请求URI定位的CoAP资源。

如果操作成功，那么向客户端发送200(OK)的响应；如果请求时不存在该资源，那么向客户端返回204(No Content)响应。
####10.2.7, CONNECT
由于没有TLS到DTLS的通道，当前HTTP-CoAP代理功能不支持本方法。因此，会向客户端返回501(Not Implemented)错误。

##11,	安全事项
本节分析协议面临的可能漏洞，并告知协议和应用开发者在本文档中CoAP的安全限制。因为CoAP实现了HTTP/1.1属性中的一个子集，在[[RFC2616]的第15节](http://tools.ietf.org/pdf/rfc2616#section-15)中的安全考虑同样与CoAP相关。本节集中描述CoAP特有的局限性。
###11.1, 解析协议和处理URIs
网络解析的应用可以显示收包处理逻辑的漏洞。复杂的解析器可能是很多漏洞的根源，比如能够远程的破坏一个节点，或者甚至在节点上执行任意的代码。CoAP尝试通过降低解析器的复杂性、限定可编码的值一个范围、主动降低在多个代表相同事件的表现上请求不常用的方法的复杂度，来减少引入这类漏洞的可能性。许多URI处理都放在客户端，更进一步减少了往服务端引入漏洞的可能性。即便这样，CoAP执行中的URI处理代码仍然可能存在许多漏洞，因此需要谨慎处理。CoAP的访问控制的实现必须保证不因为URI和通过URI定位的资源代码的差异而引入漏洞。最复杂的解析器可能是CoRE Link Format，尽管它也可能是按照减少执行复杂度的目标设计的[[RFC6690]](http://tools.ietf.org/pdf/rfc6690)，也可以参考[[RFC2616]的15.2节](http://tools.ietf.org/pdf/rfc2616#section-15.2)。
###11.2, 代理和缓存
按照[[RFC2616]中的15.7节](http://tools.ietf.org/pdf/rfc2616#section-15.7)提到的，代理由于其本身的中间人性质,可能会破坏直接CoAP消息交换的IPsec或者DTLS保护。因此，它们是CoAP消息交换中最可能破坏机密性或者完整性的。按照[[RFC2616]](http://tools.ietf.org/pdf/rfc2616)中提到的，它们也可能破坏可用性。

当代理采用缓存的时候，会加大请求/响应数据的机密性和完整性的威胁。注意，CoAP没有定义任何能够为HTTP/1.1提供更好的敏感数据保护的cache-suppressing Cache-Control选项。

对于包含cache的情况，访问控制的实现需要注意，如果请求有对应的cache条目，对应的cache数据也需要应用控制规则。这对实现多个安全域的客户端以及服务于多个客户端的代理很有意义。同样，有缓存的代理必须不能转发缓存数据给那些传输安全性更低的代理。与"coap"机制不同，对“coaps”认定的请求的响应不是“public”的，因此不能重用于共享的缓存，除非缓存能够对缓存条目进行等效的访问控制。如果CoAP中默认缓存了消息，它们能在私有的缓存中被重新利用。

最终，给多个原始请求端服务的代理可能发送单独响应(和附带响应相反)来提供额外的增幅(参考11.3)。

###11.3, 增幅的风险

CoAP服务端通常用响应包来回复请求包。响应包可能比请求包大许多。网络攻击者可能利用CoAP节点将一个小的攻击包变为一个大的攻击包，这个过程称为增幅。这就存在CoAP节点利用协议的增幅特性产生一个DoS攻击的风险：由于网络限制，攻击者占据的带宽有限，但通过扩大特性，能够使攻击者突破带宽限制。

由于UDP协议不提供验证请求包中的源地址的方法，因此在使能NoSec访问的节点中，网络攻击者能够访问它，并且能够访问潜在的被攻击者，这就存在风险。网络攻击者只需要将被攻击者的IP地址放在合适的请求包中的源地址中，就能产生定向到被攻击者的更大的包。

作为降低影响的方法，很多受限网络只能产生很小的通信量，这样使得CoAP节点在攻击中不容易被注意。然而，受限网络的有限带宽使得网络本身容易成为增幅攻击中的受害者。

因此，如果请求没有认证，在响应中不能有大的增幅因子。CoAP服务端通过使用CoAP的slicing/blocking模式和大的资源表现采用小的分配来减少为攻击者提供的增幅量。举个例子，对于一个1000字节的资源，一个10字节的请求引起一个80字节的响应(64字节的块)，而不是1016字节的响应，这样就相当的减少了提供的增幅。

CoAP也能在请求中支持多播IP地址的使用，这在M2M中是一项重要的要求。多播CoAP请求也许是事故或者DoS攻击的源头，尤其在受限网络中。本规范试图在响应返回时加一些限制来减少多播请求的增幅效果。为了减少恶意使用的可能性，CoAP服务端不能接受没被认证的多播请求，也对潜在的源加上一些多播的边界限制。可能的话，CoAP服务端应当限制对特定资源的多播请求的支持。

在提供POSIX接口API[IEEE1003.1]的通用操作系统中，很难查出一个包是否指向多播地址。很多实现能够知道自己是否已经加入多播组，采用FF0x::1格式指向多播地址的包会产生问题，这种包会被所有IPV6节点接收。实现时必须使用诸如IPV6\_RECVPKTINFO[[RFC3542]](http://tools.ietf.org/pdf/rfc3542)的新的API。

###11.4， 地址欺骗攻击

由于UDP中没有握手机制，一个欺诈端点能够自由的读写受限网络中的消息(例如NoSec或PreSharedKey中的nodes/key比率大于1：1)，这样就能轻易的使用下面手段来攻击单个端点，一组端点，甚至整个网络：

1. 在对CON消息或者NONCON消息的响应中回复一个虚假的复位消息，这样使得端点“deaf”
2. 在对CON消息的响应中回复一个虚假的ACK，这样可能会阻止CON消息的发送者重传，并让实际的响应失效。
3. 利用伪造的payload/options来欺骗整个响应(有几个不同层级的影响：从单个响应的破坏到配套基础设施的攻击，例如破坏代理缓存或者在资源目录中欺骗validation/lookup接口，更普遍的，任何储存网络状态的组件和利用CoAP为来处理和更新状态的通信设备体都是一个潜在的攻击目标。
4. 对目标节点多播欺骗请求，这会导致网络拥塞或崩溃，DoS攻击或者从强行唤醒。
5. 欺骗observe消息。

尽管没有实现基于随机token询问的安全传输层,不明来源的回应攻击可以被检测和缓和。[[RFC4086]](tools.ietf.org/pdf/rfc4086)讨论了随机询问的安全机制。

特别的，使用CON消息的CoAP能侦测到其他类型的欺骗，因为从被欺骗的端点中有攻击源发来的ACK或者RST消息。但是欺骗保持message ID的追踪是很难的，另一方面在被攻击之后，利用此对探测欺骗非常有用。这些攻击可以利用安全模式而不是NoSec来防范。

无论有没有源地址欺骗，客户端能试图往服务端发送复杂的请求来加重服务端的负载；地址欺骗使得回溯，阻塞和攻击更加困难。由于CON请求的花销很小，所以很容易执行这种攻击。在这种攻击下，带有受限电源的受限节点会比预期更快的耗尽能量(电量耗尽攻击)。如果客户端利用CON消息和服务器利用分离的CON回应一个不会响应的地址(可能是欺骗)，服务器就需要为其分配内存和对每一个未回应的节点进行回应这回耗尽服务为的MAX_TRANSMIT_SPAN，使服务器没有资源处理合法的交互。后面的问题可以可通过限制回应的速率以减缓，见4.7.攻击者可以伪装合法客户端的地址进行欺骗这可能引起服务端阻塞针对客户端的合法的回应，因为NSTART=1,。攻击是针对非安全模式的,这些攻击在安全模式被避免，而不是NoSec。

###11.5， 跨协议攻击

CoAP端点向虚假的源地址发送包不仅能用于增幅，也能用于对一个监听给定地址(IP地址和端口)的受害者进行跨协议攻击。按照下面步骤就会发生：

    攻击者往CoAP端点发送一个带有将虚假源地址当做给定地址的消息。

    CoAP端点向给定的源地址发送响应消息。

    在给定地址接收UDP包的受害者就会按照不同协议的规则进行解析。

它可以用于绕过阻止从攻击者向受害者通信的防火墙规则，但是将允许从CoAP端点(在其他协议中也担当有效角色)到受害者通信。

另外，CoAP端点可能成为由其他基于UDP协议(譬如DNS)的端点发起的跨协议攻击的受害者。在这些情况下，如果端点的安全属性依赖于检查IP地址(和使用虚假IP地址来切断外界攻击的防火墙)，就有可能遭受攻击。通常，由于基于UDP的协议缺乏上下文，因此它们更容易成为跨协议攻击的目标。

最后，由其他方式传输的CoAP URI能够用于使得客户端往其他协议的端点发送消息。

一个减轻跨协议攻击的措施是严格检查接收包的语法和语法中的足够多的差异。举个例子，如果很难使得DNS服务器向CoAP端点发送一个传递检查的DNS响应，那么就会起作用。可惜的是，DNS回复的前两个字节是能被攻击者选中的ID，并且映射为CoAP头部的关键部分，后面两个字节被当做CoAP的消息ID(任何值都可行)。DNS的计数字可以当做一个(不存在但是可选的)CoAP选项0的多重实例，或者当做一个Token。攻击者利用重复的查询来在CoAP端点上达到一个预期效果；服务端增加的响应(如果有的话)将被当做额外的负载。

    
	0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                      ID                       | T, TKL, code
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   | Message ID
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    QDCOUNT                    | (options 0)
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    ANCOUNT                    | (options 0)
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    NSCOUNT                    | (options 0)
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    ARCOUNT                    | (options 0)
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    Figure 15: DNS头部 ([RFC1035]的4.1.1节[http://tools.ietf.org/pdf/rfc1035#section-4.1.1]) 和 CoAP消息

一般来说，对于任何一对协议，协议之一很容易设计为使得攻击者生成类似另一种协议的消息的回复。比起保证或者证明不存在可实行的攻击，生成可能未完全启动的但可能被二次开发的攻击的实例通常更加困难。如果端点依据受信任包的源IP地址而没有授权攻击者，那么跨协议攻击才能完全的减轻。相反的，完全依赖防火墙的NoSec环境下的CoAP安全不仅需要防火墙来切断CoAP的端点，并且使得所有其它的端点使用一些基于UDP的协议来往CoAP端点发送UDP消息。

除了上面的考量，也要考虑跨协议攻击的DTLS安全。举例，如果相同的DTLS安全连接("connection")用于传输多种协议的数据，那么DTLS就不对这些协议提供应对跨协议攻击的保护。

###11.6	受限节点的注意事项
受限节点上的实现经常发现它们没有好的信息熵来源[RFC4086][http://tools.ietf.org/pdf/rfc4086]。在这种情况下，节点**必须**不能用于对信息熵要求高的处理过程，比如说key的生成。另外，在制造或者运行中可以生成keys并添加到设备中。

由于受限节点的低处理能力，它们最容易受到时序攻击的影响。在实现密码原语时需多加注意。

在暴露环境中安装大量的受限节点会使得它们对窜改没有抵抗能力，包括密匙内容的恢复。当定义分配给它们的认证信息时需要考虑到这一点。尤其是，当向一组节点分配一个共享的key可能使得任何一个单一的受限节点成为破换整个组的目标。